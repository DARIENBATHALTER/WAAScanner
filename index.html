<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WAA Inventory Scanner</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.5;
            color: #333;
            padding: 16px;
            max-width: 100%;
            overflow-x: hidden;
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        /* Form elements */
        .input-group {
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .radio-group {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .radio-option {
            flex: 1;
            text-align: center;
        }
        
        .radio-option input[type="radio"] {
            margin-right: 0.5rem;
        }
        
        /* Buttons */
        .btn {
            display: block;
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 4px;
            background-color: #0066cc;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        
        .btn:active {
            background-color: #005bb5;
        }
        
        .btn.secondary {
            background-color: #666;
        }
        
        .btn.secondary:active {
            background-color: #555;
        }
        
        /* Scanner */
        #scanner-container {
            width: 100%;
            height: 60vh;
            background-color: #000;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: none;
        }
        
        #scanner-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #000;
        }
        
        /* iOS-specific fixes */
        #scanner-video::-webkit-media-controls {
            display: none !important;
        }
        
        /* Add a loading indicator */
        .camera-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            z-index: 10;
        }
        
        /* Capture button styling */
        .capture-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            border: 3px solid white;
            cursor: pointer;
            z-index: 15;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .capture-button::after {
            content: '';
            display: block;
            width: 54px;
            height: 54px;
            border-radius: 50%;
            background-color: white;
        }
        
        .capture-button:active::after {
            width: 50px;
            height: 50px;
        }
        
        .tap-instruction {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            font-weight: bold;
            z-index: 10;
        }
        
        /* Status and results */
        #status-container {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 4px;
            background-color: #f5f5f5;
            display: none;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
        }
        
        .success {
            background-color: #e6ffe6;
            border-left: 4px solid #00cc00;
        }
        
        .error {
            background-color: #ffe6e6;
            border-left: 4px solid #cc0000;
        }
        
        .info {
            background-color: #e6f2ff;
            border-left: 4px solid #0066cc;
        }
        
        /* Sections */
        .setup-section, .scanner-section, .results-section {
            margin-bottom: 2rem;
        }
        
        /* Device list summary */
        #device-summary {
            padding: 1rem;
            background-color: #f5f5f5;
            border-radius: 4px;
            margin-top: 1rem;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #ddd;
        }
        
        /* View devices modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 100;
            overflow-y: auto;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            margin: 20px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close {
            float: right;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* Utility classes */
        .hidden {
            display: none;
        }
        
        /* Scanner overlay */
        .scan-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        .scan-target {
            width: 200px;
            height: 200px;
            border: 2px solid rgba(76, 175, 80, 0.8);
            border-radius: 20px;
            box-shadow: 0 0 0 4000px rgba(0, 0, 0, 0.3);
        }
        
        .scan-flash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .scan-result {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Success confirmation overlay */
        .scan-success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        
        .scan-success-content {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            width: 80%;
            max-width: 400px;
        }
        
        .scan-success-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #009900;
        }
        
        .scanned-tag {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        .scan-success-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .btn-undo {
            background-color: #ff6666;
        }
        
        .btn-confirm {
            background-color: #66cc66;
        }
    </style>
</head>
<body>
    <h1>WAA Inventory Scanner</h1>
    
    <div class="setup-section">
        <div class="input-group">
            <label for="csv-upload">Upload Inventory CSV</label>
            <input type="file" id="csv-upload" accept=".csv">
        </div>
        
        <div id="setup-details" class="hidden">
            <div class="input-group">
                <label for="teacher-location">Teacher/Location</label>
                <input type="text" id="teacher-location" placeholder="Enter teacher name or classroom">
            </div>
            
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="waa-tag" name="tag-type" value="WAA" checked>
                    <label for="waa-tag">WAA Tag</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="ipad-tag" name="tag-type" value="iPad">
                    <label for="ipad-tag">iPad Tag</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="chromebook-tag" name="tag-type" value="Chromebook">
                    <label for="chromebook-tag">Chromebook Tag</label>
                </div>
            </div>
            
            <div class="input-group">
                <input type="checkbox" id="condition-notes-check">
                <label for="condition-notes-check">Add condition notes for each scan</label>
            </div>
        </div>
    </div>
    
    <div class="scanner-section hidden" id="scanner-section">
        <button id="start-scan-btn" class="btn">Start Scanning</button>
        <button id="manual-entry-btn" class="btn secondary">Enter Tag Manually</button>
        
        <div id="scanner-container">
            <video id="scanner-video" playsinline autoplay muted></video>
            <div class="scan-overlay">
                <div class="scan-target"></div>
            </div>
            <div class="scan-flash" id="scan-flash"></div>
            <div class="scan-result" id="scan-result"></div>
            <div class="camera-loading" id="camera-loading">Accessing camera...</div>
            <div class="capture-button"></div>
            <div class="tap-instruction">Tap to capture</div>
        </div>
    </div>
    
    <div class="results-section hidden" id="results-section">
        <div id="status-container"></div>
        
        <div id="device-summary"></div>
        
        <button id="view-devices-btn" class="btn secondary">View All Devices</button>
        <button id="export-btn" class="btn">Export Updated CSV</button>
    </div>
    
    <!-- Manual Entry Modal -->
    <div id="manual-entry-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-manual-entry">&times;</span>
            <h2>Enter Tag Manually</h2>
            <div class="input-group">
                <input type="text" id="manual-tag-input" placeholder="Enter tag number" pattern="[0-9]*" inputmode="numeric">
            </div>
            <button id="submit-manual-tag" class="btn">Submit</button>
        </div>
    </div>
    
    <!-- Condition Notes Modal -->
    <div id="condition-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-condition">&times;</span>
            <h2>Device Condition</h2>
            <div class="input-group">
                <label for="condition-notes">Enter condition notes:</label>
                <input type="text" id="condition-notes" placeholder="e.g., Screen cracked, Missing charger">
            </div>
            <button id="submit-condition" class="btn">Submit</button>
        </div>
    </div>
    
    <!-- View Devices Modal -->
    <div id="view-devices-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-view-devices">&times;</span>
            <h2>All Devices</h2>
            <div id="devices-list-container"></div>
        </div>
    </div>

    <!-- Success Confirmation Overlay -->
    <div id="scan-success-overlay" class="scan-success-overlay">
        <div class="scan-success-content">
            <div class="scan-success-title">Tag Scanned Successfully</div>
            <p>Scanned Tag Number:</p>
            <div id="scanned-tag-display" class="scanned-tag">1234</div>
            <div id="device-details"></div>
            <div class="scan-success-buttons">
                <button id="btn-undo" class="btn btn-undo">Undo</button>
                <button id="btn-confirm" class="btn btn-confirm">Confirm</button>
            </div>
        </div>
    </div>

    <!-- PapaParse CSV library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

    <!-- Replace Quagga with Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

    <script>
        // Application State
        const AppState = {
            inventory: [], // Parsed CSV data
            currentTeacher: '',
            selectedTagType: 'WAA',
            enableConditionNotes: false,
            scannedTag: null,
            processingTag: false,
            // Scanner config
            scannerActive: false,
            directCameraStream: null,
            ocrWorker: null,
            lastProcessedTime: 0,
            scanInterval: null,
            // Last check-in for undo
            lastCheckedInItem: null
        };
        
        // DOM Elements
        const Elements = {
            csvUpload: document.getElementById('csv-upload'),
            setupDetails: document.getElementById('setup-details'),
            teacherLocation: document.getElementById('teacher-location'),
            tagTypeRadios: document.querySelectorAll('input[name="tag-type"]'),
            conditionCheck: document.getElementById('condition-notes-check'),
            
            scannerSection: document.getElementById('scanner-section'),
            startScanBtn: document.getElementById('start-scan-btn'),
            manualEntryBtn: document.getElementById('manual-entry-btn'),
            scannerContainer: document.getElementById('scanner-container'),
            scannerVideo: document.getElementById('scanner-video'),
            scanFlash: document.getElementById('scan-flash'),
            scanResult: document.getElementById('scan-result'),
            cameraLoading: document.getElementById('camera-loading'),
            captureButton: document.querySelector('.capture-button'),
            tapInstruction: document.querySelector('.tap-instruction'),
            
            resultsSection: document.getElementById('results-section'),
            statusContainer: document.getElementById('status-container'),
            deviceSummary: document.getElementById('device-summary'),
            viewDevicesBtn: document.getElementById('view-devices-btn'),
            exportBtn: document.getElementById('export-btn'),
            
            // Modals
            manualEntryModal: document.getElementById('manual-entry-modal'),
            manualTagInput: document.getElementById('manual-tag-input'),
            submitManualTag: document.getElementById('submit-manual-tag'),
            closeManualEntry: document.getElementById('close-manual-entry'),
            
            conditionModal: document.getElementById('condition-modal'),
            conditionNotes: document.getElementById('condition-notes'),
            submitCondition: document.getElementById('submit-condition'),
            closeCondition: document.getElementById('close-condition'),
            
            viewDevicesModal: document.getElementById('view-devices-modal'),
            devicesListContainer: document.getElementById('devices-list-container'),
            closeViewDevices: document.getElementById('close-view-devices'),
            
            // Success confirmation overlay
            scanSuccessOverlay: document.getElementById('scan-success-overlay'),
            scannedTagDisplay: document.getElementById('scanned-tag-display'),
            deviceDetails: document.getElementById('device-details'),
            btnUndo: document.getElementById('btn-undo'),
            btnConfirm: document.getElementById('btn-confirm')
        };

        // ====== Storage Service ======
        const StorageService = {
            storageKey: 'waaInventoryData',
            
            saveInventory: function(data) {
                try {
                    const serialized = JSON.stringify(data);
                    localStorage.setItem(this.storageKey, serialized);
                    return true;
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                    return false;
                }
            },
            
            loadInventory: function() {
                try {
                    const serialized = localStorage.getItem(this.storageKey);
                    return serialized ? JSON.parse(serialized) : null;
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                    return null;
                }
            },
            
            clearInventory: function() {
                localStorage.removeItem(this.storageKey);
            },
            
            saveAppState: function() {
                this.saveInventory({
                    inventory: AppState.inventory,
                    currentTeacher: AppState.currentTeacher,
                    selectedTagType: AppState.selectedTagType,
                    enableConditionNotes: AppState.enableConditionNotes
                });
            },
            
            loadAppState: function() {
                const data = this.loadInventory();
                if (data) {
                    AppState.inventory = data.inventory;
                    AppState.currentTeacher = data.currentTeacher || '';
                    AppState.selectedTagType = data.selectedTagType || 'WAA';
                    AppState.enableConditionNotes = data.enableConditionNotes || false;
                    return true;
                }
                return false;
            }
        };

        // ====== CSV Manager ======
        const CSVManager = {
            headers: [],
            
            parseCSV: function(file) {
                return new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            if (results.errors.length) {
                                reject(results.errors);
                                return;
                            }
                            
                            this.headers = results.meta.fields;
                            AppState.inventory = results.data;
                            
                            // Save to storage
                            StorageService.saveAppState();
                            resolve(results.data);
                        },
                        error: (error) => reject(error)
                    });
                });
            },
            
            exportCSV: function() {
                const csv = Papa.unparse({
                    fields: this.headers,
                    data: AppState.inventory
                });
                
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', `WAA_Inventory_Export_${new Date().toISOString().slice(0, 10)}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            },
            
            findItemByTag: function(tag) {
                const tagType = AppState.selectedTagType;
                let tagColumn;
                
                switch (tagType) {
                    case 'WAA':
                        tagColumn = 'WAA Tag';
                        break;
                    case 'iPad':
                        tagColumn = 'iPad Tag';
                        break;
                    case 'Chromebook':
                        tagColumn = 'Chromebook Tag';
                        break;
                }
                
                // Normalize tag by removing non-numeric characters and converting to string
                const normalizedTag = tag.toString().replace(/\D/g, '');
                
                // Find an item where the tag ends with the normalized tag (ignoring leading zeros)
                return AppState.inventory.find(item => {
                    if (!item[tagColumn]) return false;
                    
                    const itemTag = item[tagColumn].toString().replace(/\D/g, '');
                    
                    // If either tag is very short (1-2 digits), require exact match
                    if (normalizedTag.length <= 2 || itemTag.length <= 2) {
                        return normalizedTag === itemTag;
                    }
                    
                    // Otherwise match by trailing digits (at least 3)
                    const matchLength = Math.min(normalizedTag.length, itemTag.length, 6); // Match up to 6 digits
                    const normalizedTagEnd = normalizedTag.slice(-matchLength);
                    const itemTagEnd = itemTag.slice(-matchLength);
                    
                    return normalizedTagEnd === itemTagEnd;
                });
            },
            
            findEmptyChromebookRow: function() {
                return AppState.inventory.find(item => 
                    item['Device Type'] === 'Chromebook' && 
                    (!item['Chromebook Tag'] || item['Chromebook Tag'] === 'n/a')
                );
            },
            
            assignTagToItem: function(item, tag) {
                const tagType = AppState.selectedTagType;
                let tagColumn;
                
                switch (tagType) {
                    case 'WAA':
                        tagColumn = 'WAA Tag';
                        break;
                    case 'iPad':
                        tagColumn = 'iPad Tag';
                        break;
                    case 'Chromebook':
                        tagColumn = 'Chromebook Tag';
                        break;
                }
                
                item[tagColumn] = tag;
                return item;
            },
            
            markAsCheckedIn: function(item, notes) {
                // Store previous state for potential undo
                AppState.lastCheckedInItem = {
                    item: { ...item }, // Clone the item
                    wasCheckedIn: !!item['Checked in? (Date and time)'],
                    previousNotes: item['Notes'],
                    previousTeacher: item['Teacher'],
                    previousCheckedIn: item['Checked in? (Date and time)']
                };
                
                // Update location/teacher
                if (AppState.currentTeacher) {
                    item['Teacher'] = AppState.currentTeacher;
                }
                
                // Add timestamp
                const now = new Date().toLocaleString();
                item['Checked in? (Date and time)'] = now;
                
                // Add notes if provided
                if (notes) {
                    item['Notes'] = notes;
                }
                
                // Save changes
                StorageService.saveAppState();
                
                return item;
            },
            
            undoLastCheckIn: function() {
                if (!AppState.lastCheckedInItem) {
                    return false;
                }
                
                const { item, wasCheckedIn, previousNotes, previousTeacher, previousCheckedIn } = AppState.lastCheckedInItem;
                
                // Find the actual item in the inventory
                const inventoryItem = AppState.inventory.find(i => 
                    i['Device Type'] === item['Device Type'] && 
                    ((i['WAA Tag'] && i['WAA Tag'] === item['WAA Tag']) || 
                     (i['iPad Tag'] && i['iPad Tag'] === item['iPad Tag']) ||
                     (i['Chromebook Tag'] && i['Chromebook Tag'] === item['Chromebook Tag']))
                );
                
                if (!inventoryItem) {
                    return false;
                }
                
                // Restore previous state
                inventoryItem['Notes'] = previousNotes;
                inventoryItem['Teacher'] = previousTeacher;
                
                if (wasCheckedIn) {
                    inventoryItem['Checked in? (Date and time)'] = previousCheckedIn;
                } else {
                    inventoryItem['Checked in? (Date and time)'] = '';
                }
                
                // Save changes
                StorageService.saveAppState();
                
                // Clear last checked in item
                AppState.lastCheckedInItem = null;
                
                return true;
            },
            
            getDeviceSummary: function() {
                const total = AppState.inventory.length;
                const checkedIn = AppState.inventory.filter(item => 
                    item['Checked in? (Date and time)']
                ).length;
                
                // Device type summaries
                const deviceTypes = {};
                AppState.inventory.forEach(item => {
                    const type = item['Device Type'];
                    if (!deviceTypes[type]) {
                        deviceTypes[type] = {
                            total: 0,
                            checkedIn: 0
                        };
                    }
                    
                    deviceTypes[type].total++;
                    
                    if (item['Checked in? (Date and time)']) {
                        deviceTypes[type].checkedIn++;
                    }
                });
                
                return {
                    total,
                    checkedIn,
                    types: deviceTypes
                };
            }
        };

        // ====== Scanner Interface ======
        const ScannerInterface = {
            initialize: function() {
                return new Promise((resolve, reject) => {
                    // First stop any existing scanner
                    if (AppState.scannerActive) {
                        this.stopScanning();
                    }
                    
                    // Show the video container and loading indicator
                    Elements.scannerContainer.style.display = 'block';
                    Elements.cameraLoading.style.display = 'block';
                    Elements.cameraLoading.textContent = "Accessing camera...";
                    Elements.captureButton.style.display = 'none'; // Hide button until camera is ready
                    Elements.tapInstruction.style.display = 'none'; // Hide instructions initially
                    
                    // Set up camera access with specific iOS-friendly constraints
                    const constraints = {
                        video: { 
                            facingMode: "environment",
                            width: { min: 640, ideal: 1080, max: 1920 },
                            height: { min: 480, ideal: 720, max: 1080 }
                        },
                        audio: false
                    };
                    
                    console.log("Requesting camera with constraints:", constraints);
                    
                    navigator.mediaDevices.getUserMedia(constraints)
                        .then(stream => {
                            console.log("Direct camera access successful");
                            
                            // Store the stream for later cleanup
                            AppState.directCameraStream = stream;
                            
                            // Set up video element with the stream
                            Elements.scannerVideo.srcObject = stream;
                            Elements.scannerVideo.setAttribute('autoplay', 'true');
                            Elements.scannerVideo.setAttribute('muted', 'true');
                            Elements.scannerVideo.setAttribute('playsinline', 'true');
                            
                            // Force play - essential for iOS Safari
                            const playPromise = Elements.scannerVideo.play();
                            if (playPromise !== undefined) {
                                playPromise
                                    .then(() => {
                                        console.log("Video is playing");
                                        // Hide loading, show capture button when video is playing
                                        Elements.cameraLoading.style.display = 'none';
                                        Elements.captureButton.style.display = 'flex';
                                        Elements.tapInstruction.style.display = 'block';
                                        
                                        // Initialize Tesseract in the background
                                        this.initTesseract().then(() => {
                                            console.log("Tesseract initialized");
                                            resolve(true);
                                        }).catch(err => {
                                            console.error("Tesseract initialization error:", err);
                                            // Still resolve as camera is working
                                            resolve(true);
                                        });
                                    })
                                    .catch(err => {
                                        console.error("Error playing video:", err);
                                        Elements.cameraLoading.textContent = "Could not start video. Tap the screen.";
                                        
                                        // On iOS, we might need user interaction to start the video
                                        // Attempt to add a tap-to-play handler
                                        const tapToPlay = function() {
                                            Elements.scannerVideo.play()
                                                .then(() => {
                                                    console.log("Video started after tap");
                                                    Elements.cameraLoading.style.display = 'none';
                                                    Elements.captureButton.style.display = 'flex';
                                                    Elements.tapInstruction.style.display = 'block';
                                                    Elements.scannerContainer.removeEventListener('click', tapToPlay);
                                                })
                                                .catch(err => console.error("Still can't play:", err));
                                        };
                                        
                                        Elements.scannerContainer.addEventListener('click', tapToPlay);
                                        
                                        // Initialize Tesseract anyway
                                        this.initTesseract().then(() => {
                                            resolve(true);
                                        }).catch(err => {
                                            console.error("Tesseract initialization error:", err);
                                            resolve(true);
                                        });
                                    });
                            }
                        })
                        .catch(err => {
                            console.error("Camera access error:", err);
                            Elements.cameraLoading.style.display = 'none';
                            Elements.cameraLoading.textContent = "Camera access denied or not available";
                            Elements.cameraLoading.style.display = 'block';
                            reject(err);
                        });
                });
            },
            
            initTesseract: function() {
                return new Promise((resolve, reject) => {
                    Tesseract.createWorker({
                        logger: progress => {
                            console.log('Tesseract progress:', progress);
                        }
                    }).then(worker => {
                        AppState.ocrWorker = worker;
                        
                        // Configure Tesseract for best results with numbers
                        worker.loadLanguage('eng').then(() => {
                            worker.initialize('eng').then(() => {
                                // Set Tesseract to only look for digits
                                worker.setParameters({
                                    tessedit_char_whitelist: '0123456789',
                                    tessedit_ocr_engine_mode: 1  // Neural net LSTM engine only
                                }).then(() => {
                                    console.log("Tesseract.js initialized successfully");
                                    resolve(true);
                                });
                            });
                        });
                    }).catch(err => {
                        console.error("Tesseract initialization error:", err);
                        reject(err);
                    });
                });
            },
            
            startScanning: function() {
                Elements.scannerContainer.style.display = 'block';
                Elements.startScanBtn.textContent = 'Stop Scanning';
                AppState.scannerActive = true;
                
                // Set up capture button click handler
                Elements.captureButton.addEventListener('click', this.captureImage.bind(this));
                
                // Also allow clicking anywhere on the video to capture (helpful for iOS)
                Elements.scannerVideo.addEventListener('click', this.captureImage.bind(this));
                
                UIController.showStatus("Camera active - tap the button to capture", "info");
            },
            
            captureImage: function() {
                if (AppState.processingTag) return; // Prevent multiple captures while processing
                
                try {
                    AppState.processingTag = true;
                    
                    // Show capture effect
                    this.showScanEffect('Capturing...');
                    
                    // Create a canvas to capture the current video frame
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size to match video dimensions
                    canvas.width = Elements.scannerVideo.videoWidth;
                    canvas.height = Elements.scannerVideo.videoHeight;
                    
                    // Draw the current video frame to the canvas
                    ctx.drawImage(Elements.scannerVideo, 0, 0, canvas.width, canvas.height);
                    
                    // Convert canvas to data URL
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    // Process the image with Tesseract OCR
                    if (AppState.ocrWorker) {
                        UIController.showStatus("Processing image...", "info");
                        
                        AppState.ocrWorker.recognize(imageData)
                            .then(result => {
                                const text = result.data.text.trim();
                                console.log("OCR result:", text);
                                
                                // If we found numbers, process them
                                if (text && /\d+/.test(text)) {
                                    // Extract all numbers
                                    const numbers = text.match(/\d+/g);
                                    if (numbers && numbers.length > 0) {
                                        // Filter for only 1-4 digit numbers
                                        const validNumbers = numbers.filter(num => num.length >= 1 && num.length <= 4);
                                        
                                        if (validNumbers.length > 0) {
                                            // Use the longest valid number if there are multiple
                                            let longestNumber = '';
                                            for (let num of validNumbers) {
                                                if (num.length > longestNumber.length) {
                                                    longestNumber = num;
                                                }
                                            }
                                            
                                            this.processScannedTag(longestNumber);
                                            return;
                                        }
                                    }
                                }
                                
                                // If no valid numbers found, show error and reset
                                UIController.showStatus("No valid tag numbers found. Try again.", "error");
                                AppState.processingTag = false;
                            })
                            .catch(err => {
                                console.error("OCR error:", err);
                                UIController.showStatus("Error processing image. Try again.", "error");
                                AppState.processingTag = false;
                            });
                    } else {
                        UIController.showStatus("OCR engine not initialized. Please try manual entry.", "error");
                        AppState.processingTag = false;
                    }
                } catch (err) {
                    console.error("Error capturing image:", err);
                    UIController.showStatus("Error capturing image. Try again.", "error");
                    AppState.processingTag = false;
                }
            },
            
            stopScanning: function() {
                // Remove event listeners
                Elements.captureButton.removeEventListener('click', this.captureImage);
                Elements.scannerVideo.removeEventListener('click', this.captureImage);
                
                // Stop and terminate Tesseract worker
                if (AppState.ocrWorker) {
                    AppState.ocrWorker.terminate()
                        .then(() => {
                            console.log("Tesseract worker terminated");
                            AppState.ocrWorker = null;
                        })
                        .catch(err => {
                            console.error("Error terminating Tesseract worker:", err);
                        });
                }
                
                // Stop direct camera stream
                if (AppState.directCameraStream) {
                    console.log("Stopping direct camera stream");
                    try {
                        const tracks = AppState.directCameraStream.getTracks();
                        tracks.forEach(track => track.stop());
                        AppState.directCameraStream = null;
                    } catch (err) {
                        console.error("Error stopping camera stream:", err);
                    }
                }
                
                // Reset UI and flags
                AppState.scannerActive = false;
                Elements.scannerContainer.style.display = 'none';
                Elements.startScanBtn.textContent = 'Start Scanning';
                Elements.scannerVideo.srcObject = null;
                Elements.cameraLoading.style.display = 'none';
                Elements.captureButton.style.display = 'none';
                Elements.tapInstruction.style.display = 'none';
            },
            
            showScanEffect: function(message) {
                // Flash effect
                const flash = Elements.scanFlash;
                flash.style.opacity = '0.3';
                
                // Show scanned message in the result display
                const result = Elements.scanResult;
                result.textContent = message;
                result.style.opacity = '1';
                
                // Fade out effects after a delay
                setTimeout(() => {
                    flash.style.opacity = '0';
                    // Keep the result visible longer
                    setTimeout(() => {
                        result.style.opacity = '0';
                    }, 1000);
                }, 300);
            },
            
            processScannedTag: function(tag) {
                console.log("Processing scanned tag:", tag);
                
                // Find matching item in inventory
                let matchedItem = CSVManager.findItemByTag(tag);
                let isNewAssignment = false;
                
                // If no match found and this is a Chromebook tag, try to assign to empty row
                if (!matchedItem && AppState.selectedTagType === 'Chromebook') {
                    const emptyRow = CSVManager.findEmptyChromebookRow();
                    
                    if (emptyRow) {
                        matchedItem = CSVManager.assignTagToItem(emptyRow, tag);
                        isNewAssignment = true;
                    }
                }
                
                if (matchedItem) {
                    // Play a success beep
                    const beep = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vm//Md///uc///AYgPh/feZ/+D/X//H5/aH//3+///w+v//+//1+//+//+/+//1/+Pz//n///9//tt///+//v//+///1//+/+//+//uAEyAA==");
                    beep.play().catch(err => console.error("Error playing beep:", err));
                    
                    // Show the success confirmation overlay with the scanned tag
                    this.showSuccessConfirmation(tag, matchedItem, isNewAssignment);
                } else {
                    // No match found
                    UIController.showStatus(
                        `No matching device found for ${AppState.selectedTagType} tag: ${tag}`, 
                        'error'
                    );
                    
                    // Reset processing flag after a delay
                    setTimeout(() => {
                        AppState.processingTag = false;
                    }, 2000);
                }
            },
            
            showSuccessConfirmation: function(tag, item, isNewAssignment) {
                // Display the tag number
                Elements.scannedTagDisplay.textContent = tag;
                
                // Show device details
                const deviceInfo = `${item['Device Type']} - ${item['Make / Model']}`;
                const statusText = isNewAssignment 
                    ? `Will be assigned to: ${deviceInfo}`
                    : `Will be checked in: ${deviceInfo}`;
                    
                Elements.deviceDetails.innerHTML = `<p>${statusText}</p>`;
                
                // Setup the buttons
                Elements.btnUndo.onclick = () => {
                    // Hide the overlay
                    Elements.scanSuccessOverlay.style.display = 'none';
                    AppState.processingTag = false;
                    UIController.showStatus("Scan cancelled", "info");
                };
                
                Elements.btnConfirm.onclick = () => {
                    // Hide the overlay
                    Elements.scanSuccessOverlay.style.display = 'none';
                    
                    // Check if condition notes are needed
                    if (AppState.enableConditionNotes) {
                        // Store the tag for the condition modal callback
                        AppState.scannedTag = {
                            tag,
                            item: item,
                            isNewAssignment
                        };
                        
                        // Show condition modal
                        Elements.conditionNotes.value = '';
                        Elements.conditionModal.style.display = 'block';
                    } else {
                        // Complete the check-in without notes
                        this.completeCheckIn(item, isNewAssignment);
                    }
                };
                
                // Show the overlay
                Elements.scanSuccessOverlay.style.display = 'flex';
            },
            
            completeCheckIn: function(item, isNewAssignment, notes = '') {
                // Mark the item as checked in
                CSVManager.markAsCheckedIn(item, notes);
                
                // Show success message
                const deviceInfo = `${item['Device Type']} - ${item['Make / Model']}`;
                const statusText = isNewAssignment 
                    ? `Assigned tag to ${deviceInfo}`
                    : `Checked in: ${deviceInfo}`;
                
                UIController.showStatus(statusText, 'success');
                
                // Update device summary
                UIController.updateDeviceSummary();
                
                // Reset processing flag after a delay
                setTimeout(() => {
                    AppState.processingTag = false;
                    
                    // Resume scanning if still active and not manually stopped
                    if (AppState.scannerActive) {
                        // Restart the scan interval
                        this.startScanning();
                    }
                }, 2000);
            },
            
            showScanError: function(message) {
                UIController.showStatus(message, 'error');
                Elements.startScanBtn.textContent = 'Start Scanning';
            }
        };

        // ====== UI Controller ======
        const UIController = {
            init: function() {
                // Check for saved inventory
                const hasSavedData = StorageService.loadAppState();
                
                if (hasSavedData) {
                    this.enterScanningMode();
                    
                    // Update UI based on saved state
                    Elements.teacherLocation.value = AppState.currentTeacher;
                    
                    // Set the correct radio button
                    Elements.tagTypeRadios.forEach(radio => {
                        if (radio.value === AppState.selectedTagType) {
                            radio.checked = true;
                        }
                    });
                    
                    Elements.conditionCheck.checked = AppState.enableConditionNotes;
                    
                    // Show device summary
                    this.updateDeviceSummary();
                }
                
                this.attachEventListeners();
            },
            
            attachEventListeners: function() {
                // CSV Upload
                Elements.csvUpload.addEventListener('change', async (e) => {
                    if (e.target.files.length === 0) return;
                    
                    const file = e.target.files[0];
                    
                    try {
                        await CSVManager.parseCSV(file);
                        this.showStatus('CSV uploaded successfully!', 'success');
                        this.enterScanningMode();
                        this.updateDeviceSummary();
                    } catch (error) {
                        console.error('Error parsing CSV:', error);
                        this.showStatus('Error uploading CSV. Please check the file format.', 'error');
                    }
                });
                
                // Teacher/Location input
                Elements.teacherLocation.addEventListener('change', (e) => {
                    AppState.currentTeacher = e.target.value;
                    StorageService.saveAppState();
                });
                
                // Tag type selection
                Elements.tagTypeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        AppState.selectedTagType = e.target.value;
                        StorageService.saveAppState();
                    });
                });
                
                // Condition notes checkbox
                Elements.conditionCheck.addEventListener('change', (e) => {
                    AppState.enableConditionNotes = e.target.checked;
                    StorageService.saveAppState();
                });
                
                // Scanner controls
                Elements.startScanBtn.addEventListener('click', () => {
                    if (AppState.scannerActive) {
                        ScannerInterface.stopScanning();
                    } else {
                        // iOS often needs user interaction directly before accessing camera
                        this.showStatus("Accessing camera...", "info");
                        
                        ScannerInterface.initialize()
                            .then(() => ScannerInterface.startScanning())
                            .catch(err => {
                                console.error('Error initializing scanner:', err);
                                this.showStatus('Failed to access camera. Please check permissions.', 'error');
                            });
                    }
                });
                
                // Manual entry
                Elements.manualEntryBtn.addEventListener('click', () => {
                    Elements.manualTagInput.value = '';
                    Elements.manualEntryModal.style.display = 'block';
                });
                
                Elements.submitManualTag.addEventListener('click', () => {
                    const tag = Elements.manualTagInput.value.trim();
                    if (tag) {
                        Elements.manualEntryModal.style.display = 'none';
                        ScannerInterface.processScannedTag(tag);
                    }
                });
                
                Elements.closeManualEntry.addEventListener('click', () => {
                    Elements.manualEntryModal.style.display = 'none';
                });
                
                // Condition modal
                Elements.submitCondition.addEventListener('click', () => {
                    const notes = Elements.conditionNotes.value.trim();
                    
                    if (AppState.scannedTag) {
                        ScannerInterface.completeCheckIn(
                            AppState.scannedTag.item,
                            AppState.scannedTag.isNewAssignment,
                            notes
                        );
                        
                        AppState.scannedTag = null;
                    }
                    
                    Elements.conditionModal.style.display = 'none';
                });
                
                Elements.closeCondition.addEventListener('click', () => {
                    // If condition modal is closed without submitting, still complete the check-in
                    if (AppState.scannedTag) {
                        ScannerInterface.completeCheckIn(
                            AppState.scannedTag.item,
                            AppState.scannedTag.isNewAssignment
                        );
                        
                        AppState.scannedTag = null;
                    }
                    
                    Elements.conditionModal.style.display = 'none';
                });
                
                // View devices
                Elements.viewDevicesBtn.addEventListener('click', () => {
                    this.renderDevicesList();
                    Elements.viewDevicesModal.style.display = 'block';
                });
                
                Elements.closeViewDevices.addEventListener('click', () => {
                    Elements.viewDevicesModal.style.display = 'none';
                });
                
                // Export button
                Elements.exportBtn.addEventListener('click', () => {
                    CSVManager.exportCSV();
                });
                
                // Handle undo button in view devices modal
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('undo-check-in')) {
                        e.preventDefault();
                        const success = CSVManager.undoLastCheckIn();
                        if (success) {
                            this.showStatus("Check-in has been undone", "success");
                            this.updateDeviceSummary();
                            this.renderDevicesList(); // Refresh the list
                        } else {
                            this.showStatus("Could not undo the last check-in", "error");
                        }
                    }
                });
                
                // Close modals when clicking outside
                window.addEventListener('click', (e) => {
                    if (e.target === Elements.manualEntryModal) {
                        Elements.manualEntryModal.style.display = 'none';
                    }
                    if (e.target === Elements.conditionModal) {
                        // Don't automatically close condition modal without handling the scan
                    }
                    if (e.target === Elements.viewDevicesModal) {
                        Elements.viewDevicesModal.style.display = 'none';
                    }
                });
            },
            
            enterScanningMode: function() {
                Elements.setupDetails.classList.remove('hidden');
                Elements.scannerSection.classList.remove('hidden');
                Elements.resultsSection.classList.remove('hidden');
            },
            
            showStatus: function(message, type = 'info') {
                Elements.statusContainer.textContent = message;
                Elements.statusContainer.className = type;
                Elements.statusContainer.style.display = 'block';
                
                // Hide after 8 seconds (increased from 5)
                setTimeout(() => {
                    Elements.statusContainer.style.display = 'none';
                }, 8000);
            },
            
            updateDeviceSummary: function() {
                const summary = CSVManager.getDeviceSummary();
                
                let html = `<h3>Device Summary</h3>
                           <p>${summary.checkedIn} of ${summary.total} devices checked in (${Math.round(summary.checkedIn/summary.total*100)}%)</p>`;
                
                // Create type-specific summaries
                html += '<div class="device-types">';
                
                for (const [type, data] of Object.entries(summary.types)) {
                    const percent = Math.round(data.checkedIn / data.total * 100);
                    html += `<div class="summary-item">
                                <span>${type}:</span>
                                <span>${data.checkedIn} / ${data.total} (${percent}%)</span>
                             </div>`;
                }
                
                html += '</div>';
                
                Elements.deviceSummary.innerHTML = html;
            },
            
            renderDevicesList: function() {
                const groupedByTeacher = {};
                
                // Group by teacher/location
                AppState.inventory.forEach(item => {
                    const teacher = item['Teacher'] || 'Unassigned';
                    
                    if (!groupedByTeacher[teacher]) {
                        groupedByTeacher[teacher] = [];
                    }
                    
                    groupedByTeacher[teacher].push(item);
                });
                
                let html = '<div class="device-list">';
                
                for (const [teacher, items] of Object.entries(groupedByTeacher)) {
                    html += `<h3>${teacher}</h3>`;
                    
                    // Group by device type within each teacher
                    const groupedByType = {};
                    
                    items.forEach(item => {
                        const type = item['Device Type'];
                        
                        if (!groupedByType[type]) {
                            groupedByType[type] = [];
                        }
                        
                        groupedByType[type].push(item);
                    });
                    
                    for (const [type, typeItems] of Object.entries(groupedByType)) {
                        html += `<h4>${type} (${typeItems.length})</h4>`;
                        
                        html += '<table style="width: 100%; border-collapse: collapse; margin-bottom: 1rem;">'+
                                '<tr style="background-color: #f5f5f5;">'+
                                '<th style="text-align: left; padding: 0.5rem;">Model</th>'+
                                '<th style="text-align: left; padding: 0.5rem;">Tag</th>'+
                                '<th style="text-align: left; padding: 0.5rem;">Checked In</th>'+
                                '</tr>';
                        
                        typeItems.forEach(item => {
                            const isCheckedIn = item['Checked in? (Date and time)'] ? true : false;
                            let tagValue = '';
                            
                            // Determine which tag to display
                            if (type === 'iPad') {
                                tagValue = item['iPad Tag'];
                            } else if (type === 'Chromebook') {
                                tagValue = item['Chromebook Tag'];
                            } else {
                                tagValue = item['WAA Tag'];
                            }
                            
                            html += `<tr style="border-bottom: 1px solid #ddd;">
                                        <td style="padding: 0.5rem;">${item['Make / Model']}</td>
                                        <td style="padding: 0.5rem;">${tagValue || 'n/a'}</td>
                                        <td style="padding: 0.5rem;">${isCheckedIn ? '' : ''}</td>
                                     </tr>`;
                        });
                        
                        html += '</table>';
                    }
                }
                
                html += '</div>';
                
                Elements.devicesListContainer.innerHTML = html;
            }
        };

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            UIController.init();
        });
    </script>
</body>
</html> 